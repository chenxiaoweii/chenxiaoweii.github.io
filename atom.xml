<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一期一会</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.dujiong.net/"/>
  <updated>2016-06-28T13:44:11.856Z</updated>
  <id>http://blog.dujiong.net/</id>
  
  <author>
    <name>dujiong</name>
    <email>dujiong.uestc@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>muduo源码阅读之muduo的回调函数机制</title>
    <link href="http://blog.dujiong.net/2016/04/28/muduo-2/"/>
    <id>http://blog.dujiong.net/2016/04/28/muduo-2/</id>
    <published>2016-04-28T11:18:24.000Z</published>
    <updated>2016-06-28T13:44:11.856Z</updated>
    
    <content type="html">&lt;p&gt;回调是指将一段可执行的代码作为变量传给另外一部分代码，以供同步或异步调用。在Reactor模式中，在事件到来时调用相应的处理函数就是一种异步回调的过程。回调函数的实现可以由各种各样的方式。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;C语言的函数指针&quot;&gt;&lt;a href=&quot;#C语言的函数指针&quot; class=&quot;headerlink&quot; title=&quot;C语言的函数指针&quot;&gt;&lt;/a&gt;C语言的函数指针&lt;/h3&gt;&lt;p&gt;最熟悉的回调机制应该属于C语言的函数指针了。考虑一个简单的例子，实现对两个数的操作，这个操作可以是加减乘除等。&lt;br&gt;首先声明一个函数指针：           &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef int (operFunc*)(int a, int b);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个类型的函数指针可以做为参数传给用于实现两个数操作的函数，这个函数仅仅是简单的调用传入的函数指针：                                                                                  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int operation(int a, int b, operFunc func)
{
    return func(a,b);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在可以定义各种回调函数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int add(int a, int b) 
{
    return a + b;
}
int minus(int a, int b) 
{   
    return a - b;
}
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样，在调用operation()时可以根据传入回调函数的不同，实现不同的功能。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int main()
{
    int a = 4;
    int b = 2;
    std::cout &amp;lt;&amp;lt; operation(a,b,add) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; operation(a,b,minus);
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;传统C-的事件回调&quot;&gt;&lt;a href=&quot;#传统C-的事件回调&quot; class=&quot;headerlink&quot; title=&quot;传统C++的事件回调&quot;&gt;&lt;/a&gt;传统C++的事件回调&lt;/h3&gt;&lt;p&gt;在传统的C++程序中，事件回调是通过虚函数进行的。网络库往往会定义一个或几个抽象基类，其中声明一些(纯)虚函数，使用者需要继承这些基类，并覆写这些虚函数，以获得事件回调通知。由于C++的动态绑定只能通过指针和引用实现，使用者必须把派生类（myHandler）对象的指针或引用隐士转换为基类(Handler)的指针或引用。网络库调用积累的虚函数，通过动态绑定机制实际调用的是用户在派生类中覆写的虚函数。&lt;br&gt;下面通过一段代码示例看看虚函数如何实现回调。   &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
class Handler    //interface
{
    public:
        virtual void say(const char* text) = 0;
};

class MyHandler : public Handler
{
    public:
        void say(const char* text)
        {
            printf(&amp;quot;hello,%s&amp;quot;,text);
        }    
};

int main()
{
    Handler *handler;
    MyHandler myHandler;
    handler = dynamic_cast&amp;lt;Hander*&amp;gt;(myHandler);
    handler.say(&amp;quot;world&amp;quot;);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;muduo采用的事件回调&quot;&gt;&lt;a href=&quot;#muduo采用的事件回调&quot; class=&quot;headerlink&quot; title=&quot;muduo采用的事件回调&quot;&gt;&lt;/a&gt;muduo采用的事件回调&lt;/h3&gt;&lt;p&gt;muduo使用的是boost库的boost::function和boost::bind实现函数回调。现在，已经可以在c++11中使用它们。&lt;br&gt;boost::function类似于函数指针的封装，boost::function类型的变量可以保存一个可以调用的函数指针。可以指向任何函数，包括成员函数。所以boost::function与boost::bind结合起来使用可以实现一些函数指针无法完成的功能，比如，绑定特定变量到函数上，实现某些函数式编程语言的功能，甚至是真正的闭包。&lt;br&gt;以下的例子均使用c++11。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;functional&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;iostream&amp;gt;

namespace
{
    void function(int number, float floation, std::string string)
    {
        std::cout &amp;lt;&amp;lt; &amp;quot;Int: \&amp;quot;&amp;quot; &amp;lt;&amp;lt; number &amp;lt;&amp;lt; &amp;quot;\&amp;quot; Float: \&amp;quot;&amp;quot; &amp;lt;&amp;lt; floatation
                  &amp;lt;&amp;lt; &amp;quot;\&amp;quot; String: \&amp;quot;&amp;quot; &amp;lt;&amp;lt; string &amp;lt;&amp;lt; &amp;quot;\&amp;quot;&amp;quot; &amp;lt;&amp;lt; std::endl; 
    }
}

int main()
{
    //declare function pointer variables 
    std::function&amp;lt;void(std::string, float, int)&amp;gt; shuffleFunction;
    std::function&amp;lt;void(void)&amp;gt; voidFunction;
    std::function&amp;lt;void(float)&amp;gt; reduceFunction;

    //bind the method
    shuffleFunction = std::bind(::function,_3,_2,_1);
    voidFunction = std::bind(::function, 5,5.f, &amp;quot;five&amp;quot;);
    reduceFunction = std::bind(::function, 13, _1, &amp;quot;empty&amp;quot;);

    //call
    shuffleFunction(&amp;quot;String&amp;quot;,0.f,0);
    voidFunction();
    reduceFunction(13.f);

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此外，还有指向成员函数的回调函数，如下例。&lt;br&gt;首先定义类A：    &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class A
{
    public:
        int add(int a, int b)
        {
            std::cout &amp;lt;&amp;lt; &amp;quot;A::add()&amp;quot; &amp;lt;&amp;lt; endl
            return a + b;
        }
}；
typedef int (A::*operFunc)(int, int);
int main(void)
{
    operFunc oper = &amp;amp;A::add;
    A ca;
    int a = 2;
    int b = 3;
    int res = (ca.*oper)(a, b);
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;成员函数具有隐含的this指针，在调用成员函数时必须通过类的实例。所以成员函数指针变量不仅在定义时有特殊的语法，更重要的是在实际调用回调函数必须采用(a.*oper)(a,b)这样的形式。这样的语法比较复杂，由于与非成员函数的声明不同，无法传入同一个函数。所以，需要调用函数既能接收成员函数又能接收非成员函数。&lt;br&gt;这就是在muduo库中广泛应用的function和bind的机制，如下代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class A
{
    ...
}；
typedef std::function&amp;lt;int(int,int)&amp;gt; operFunc;
int main()
{
    int a = 2;
    int b = 4;
    operFunc oper;
    A ca;
    oper = std::bind(&amp;amp;A::add, &amp;amp;ca, _1, _2);
    std::out &amp;lt;&amp;lt; operation(a,b,oper) &amp;lt;&amp;lt; std::endl;
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在muduo中，一个回调函数通常是一个类的成员函数，所以这个回调函数同时也保存了某个类实例的信息，包括这个类的成员变量、成员函数等，在实际调用函数的时候就可以使用这些信息和状态，这样的处理当时让程序的编写显得非常清晰和方便。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;回调是指将一段可执行的代码作为变量传给另外一部分代码，以供同步或异步调用。在Reactor模式中，在事件到来时调用相应的处理函数就是一种异步回调的过程。回调函数的实现可以由各种各样的方式。&lt;br&gt;
    
    </summary>
    
    
      <category term="muduo" scheme="http://blog.dujiong.net/tags/muduo/"/>
    
  </entry>
  
  <entry>
    <title>muduo源码阅读之Reactor模式和muduo</title>
    <link href="http://blog.dujiong.net/2016/04/25/muduo-1/"/>
    <id>http://blog.dujiong.net/2016/04/25/muduo-1/</id>
    <published>2016-04-25T10:56:03.000Z</published>
    <updated>2016-06-28T12:17:55.078Z</updated>
    
    <content type="html">&lt;p&gt;muduo是一个基于Reactor模式的非阻塞网络库，常见的使用Reactor模式的网络库（框架）还有libevent,Java Netty等，所以，首先需要弄清楚Reactor模式。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Reactor的事件处理机制&quot;&gt;&lt;a href=&quot;#Reactor的事件处理机制&quot; class=&quot;headerlink&quot; title=&quot;Reactor的事件处理机制&quot;&gt;&lt;/a&gt;Reactor的事件处理机制&lt;/h3&gt;&lt;p&gt;首先回忆一下普通函数调用的机制：程序调用某函数执行，程序等待，函数将结果和控制权返回给程序，程序继续处理。这是一种顺序的处理方式。&lt;br&gt;Reactor常释义“反应堆”，是一种事件驱动机制，和普通函数调用的不同之处在于：应用程度不是主动的调用某个接口API完成处理，恰恰相反，Reactor逆置了事件处理流程，应用程序需要提供相应的接口并注册到Reactor上，如果关注的事件发生，Reactor将主动调用应用程序注册的接口，这些接口有一个熟悉的名字：“回调函数”。所以，用户使用Reactor模式的网络库向其注册相应的事件和回调函数，当事件发生时，就会调用回调函数处理事件（I/O读写，定时器和信号等）。Reactor模式一般与非阻塞I/O结合，在处理一个事件时不用等待事件的完成，而是转去处理其他的任务，当事件处理完毕后再去通知Reactor。&lt;br&gt;所以，Reactor模式具有很多优点：&lt;br&gt;1）响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的；&lt;br&gt;2）编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；&lt;br&gt;3）可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源；&lt;br&gt;4）可复用性，Reactor框架本身与具体事件处理逻辑无关，具有很高的复用性；&lt;/p&gt;
&lt;h3 id=&quot;Reactor模式的结构&quot;&gt;&lt;a href=&quot;#Reactor模式的结构&quot; class=&quot;headerlink&quot; title=&quot;Reactor模式的结构&quot;&gt;&lt;/a&gt;Reactor模式的结构&lt;/h3&gt;&lt;p&gt;Reactor模式包括四个部分的组件:&lt;br&gt;1）事件源（Handle）&lt;br&gt;用于表示通过操作系统管理的各种资源，包括套接字，打开文件，定时器等，在Unix系统中是文件描述符，在Windows系统中是句柄。当关心的事件在其上面发生时，可以通过多路复用器(select/epoll等)得到。&lt;br&gt;2）Synchronous Event Demultiplexer&lt;br&gt;事件多路分发机制。由操作系统提供的I/O多路复用机制，如select/epoll等。程序首先将关心的事件源注册到event demultiplexer上，当有事件到达时，event demultiplexer会发出通知“在已经注册的句柄集中，一个或多个句柄已经就绪”。&lt;br&gt;3）Initiation Dispatcher&lt;br&gt;事件管理的接口，实现事件的注册，删除，分发的接口，并运行事件循环，是用于驱动的主模块。Synchronous Event Demultiplexer也是它的一个组件，用于等待新事件的发生。当有事件发生时，Demultiplexer通知dispatcher，dispatcher再根据事件的类型使用相应的Event Hander完成事件的处理。&lt;br&gt;3）Event Handler&lt;br&gt;事件处理程序。一般来说会根据事件类型的不同实现各种类型的回调函数。&lt;/p&gt;
&lt;p&gt;下图可详细表达各个模块和它们之间的关系：&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/052r16x.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;muduo中的Reactor模式&quot;&gt;&lt;a href=&quot;#muduo中的Reactor模式&quot; class=&quot;headerlink&quot; title=&quot;muduo中的Reactor模式&quot;&gt;&lt;/a&gt;muduo中的Reactor模式&lt;/h3&gt;&lt;p&gt;Reactor模式的各个组件在muduo中都有对应的部分，虽然在具体的实现和逻辑上有其自身的特点和不同，但其内在的组织结构是高度符合Reactor模式的。&lt;br&gt;muduo的类图如下：                                                                                    &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/M4uVBf1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;各个模块与Reactor模式各组件的对应关系（功能上）是    &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Initialization dispatcher —— EventLoop    &lt;/li&gt;
&lt;li&gt;Synchronous Event Demultiplexer —— Poller     &lt;/li&gt;
&lt;li&gt;Handles —— FileDescriptor、Channel    &lt;/li&gt;
&lt;li&gt;Event Handler —— TcpConnection、Acceptor、Connector&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;muduo中的思想&quot;&gt;&lt;a href=&quot;#muduo中的思想&quot; class=&quot;headerlink&quot; title=&quot;muduo中的思想&quot;&gt;&lt;/a&gt;muduo中的思想&lt;/h3&gt;&lt;p&gt;有一个main Reactor，这个main Reactor只管接收新的连接，一旦创建好连接，就从EventLoopThreadPool（线程池）中选择一个合适的EventLoop来托管这个连接套接字。这个EventLoop就是一个sub Reactor。&lt;br&gt;muduo的线程模型是one loop per thread + thread pool模型。每个线程最多有一个EventLoop，每个TcpConnection必须归某个EventLoop管理，所有的I/O会转移到这个线程。即，一个句柄只能由一个线程读写。&lt;br&gt;TcpServer直接支持支持多线程，有两种模式：&lt;br&gt;1）单线程，accept()与TcpConnection用同一个线程做IO；&lt;br&gt;2）多线程，accept()与EventLoop在同一个线程，另外创建一个EventLoopThreadPool，新的连接会分配到线程池中。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;muduo是一个基于Reactor模式的非阻塞网络库，常见的使用Reactor模式的网络库（框架）还有libevent,Java Netty等，所以，首先需要弄清楚Reactor模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="muduo" scheme="http://blog.dujiong.net/tags/muduo/"/>
    
  </entry>
  
  <entry>
    <title>wifi关键指标提取</title>
    <link href="http://blog.dujiong.net/2016/04/20/wifi-data-get/"/>
    <id>http://blog.dujiong.net/2016/04/20/wifi-data-get/</id>
    <published>2016-04-20T01:56:09.000Z</published>
    <updated>2016-05-20T02:20:22.606Z</updated>
    
    <content type="html">&lt;p&gt;本文介绍并实现无线网卡获取周围wifi关键通信数据，捕捉所需要的MAC层管理数据包，通过解包获取到周围AP和终端设备的MAC地址和RSSI，并存入数据库中，可用于定位，通信链路分析等。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;###基本方法&lt;br&gt;在实现MAC地址和RSSI的提取时，借鉴了OpenWRT现有的iwcap工具包，iwcap是OpenWRT上用来调试wifi功能的一个抓包工具，可以抓取监听到的所有802.11帧，并获取到pcap格式的网卡原始数据。&lt;/p&gt;
&lt;p&gt;###程序分析&lt;br&gt;详细程序见: &lt;a href=&quot;https://github.com/jiongdu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍并实现无线网卡获取周围wifi关键通信数据，捕捉所需要的MAC层管理数据包，通过解包获取到周围AP和终端设备的MAC地址和RSSI，并存入数据库中，可用于定位，通信链路分析等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="openwrt" scheme="http://blog.dujiong.net/tags/openwrt/"/>
    
      <category term="wifi" scheme="http://blog.dujiong.net/tags/wifi/"/>
    
  </entry>
  
  <entry>
    <title>C++内存管理--部分总结</title>
    <link href="http://blog.dujiong.net/2016/04/13/cplusplusMem/"/>
    <id>http://blog.dujiong.net/2016/04/13/cplusplusMem/</id>
    <published>2016-04-13T11:11:16.000Z</published>
    <updated>2016-05-13T13:24:06.775Z</updated>
    
    <content type="html">&lt;p&gt;可以说，内存管理是c/c++程序员面临的最重要的问题之一，同时很多时候也是最麻烦的事情。所以，这里对简单层次的内存管理做下总结和说明，同时，例举了一些常见的内存错误及解决策略。&lt;/p&gt;
&lt;h3 id=&quot;野指针&quot;&gt;&lt;a href=&quot;#野指针&quot; class=&quot;headerlink&quot; title=&quot;野指针&quot;&gt;&lt;/a&gt;野指针&lt;/h3&gt;&lt;p&gt;在c/c++内存问题中经常听到野指针这个词语，那么到底什么事野指针？野指针是怎样形成的？&lt;br&gt;首先，野指针不是NULL指针，而是指向”垃圾”内存的指针。NULL指针用if语句很容易判断，但是野指针很危险，if语句对其不起作用。&lt;br&gt;野指针的成因主要有下列几种：&lt;br&gt;(1) 指针变量没有初始化。 任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。&lt;br&gt;(2) 指针被free()或者delete之后，没有置为NULL，让人误以为其是个合法的指针。  这点是实际运用过程中极易犯错误的。&lt;br&gt;(3) 指针操作超越了变量的作用范围。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;new-delete和malloc-free&quot;&gt;&lt;a href=&quot;#new-delete和malloc-free&quot; class=&quot;headerlink&quot; title=&quot;new/delete和malloc()/free()&quot;&gt;&lt;/a&gt;new/delete和malloc()/free()&lt;/h3&gt;&lt;p&gt;c/c++程序员想必不会陌生。注意它们的区别和联系。&lt;br&gt;(1) new/delete是c++的操作符,而malloc()/free()是c/c++的一个函数。&lt;br&gt;(2) new不只是内存分配，在内存分配后，还会调用类的构造函数，同样，delete会调用类的析构函数。而malloc()只分配内存，不初始化成员，free也不会调用析构函数。所以，new可以认为是malloc()加构造函数的执行。&lt;br&gt;(3) 因为new会调用类的构造函数，所以new出来的指针式直接带类型信息的，而malloc()返回的都是void指针。&lt;br&gt;(4) 同样的原因，对于非内部数据类型的对象而言，只用malloc()/free()无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，在消亡之前要自动执行析构函数。由于malloc()/free()是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc()/free()。而由于内部数据类型的“对象”没有构造与析构的过程，对它们而言malloc()/free()和new/delete是等价的。&lt;br&gt;(5) 如果用free()释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。同样，用delete释放”malloc()申请的动态内存”。理论上讲程序不会出错，但是该程序的可读性很差。所以，new/delete必须配对使用，malloc()/free()也一样。&lt;/p&gt;
&lt;p&gt;一些易错点：&lt;br&gt;(1) malloc()函数本身并不识别要申请的内存是什么类型，而只关心内存的总字节数。malloc()返回值的类型是void&lt;em&gt;,&lt;/em&gt;所以在调用malloc()时要显示地进行类型转换，将void*转换成所需要的指针类型。&lt;br&gt;(2) 语句free(p)之所以能正确地释放内存.是因为指针p的类型以及它所指的内存的容量事先都是知道的。如果p是NULL指针，那么free对p无论操作多少次都不会出问题。如果p不是NULL指针，那么free对p连续操作两次就会导致程序运行错误。&lt;br&gt;(3) 运算符new使用起来要比函数malloc简单得多，这是因为new内置了sizeof、类型转换和类型安全检查功能。对于非内部数据类型的对象而言，new在创建动态对象的同时完成了初始化工作。如果对象有多个构造函数，那么new的语句也可以有多种形式。而如果用new创建对象数组，那么只能使用对象的无参数构造函数。          &lt;/p&gt;
&lt;h3 id=&quot;常见的内存错误及策略&quot;&gt;&lt;a href=&quot;#常见的内存错误及策略&quot; class=&quot;headerlink&quot; title=&quot;常见的内存错误及策略&quot;&gt;&lt;/a&gt;常见的内存错误及策略&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;(1) 内存分配未成功，却使用了它&lt;/strong&gt;&lt;br&gt;编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc()或new()来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。&lt;br&gt;(2) 内存分配虽然成功，但是尚未初始化就引用它&lt;br&gt;犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。&lt;br&gt;内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。&lt;br&gt;&lt;strong&gt;(3) 内存分配成功并且已经初始化，但操作越过了内存的边界&lt;/strong&gt;&lt;br&gt;例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。&lt;br&gt;&lt;strong&gt;(4) 忘记了释放内存，造成内存泄露&lt;/strong&gt;&lt;br&gt; 含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。&lt;br&gt;&lt;strong&gt;(5) 释放了内存却继续使用它（常见有三种情况）&lt;/strong&gt;&lt;br&gt;a. 程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。&lt;br&gt;b. 函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。&lt;br&gt;c. 使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。&lt;/p&gt;
&lt;p&gt;以上是对常见的一些内存问题的解决策略的总结。错误率特别高的部分已经用黑体标出，需注意。&lt;/p&gt;
&lt;h3 id=&quot;指针和数组的对比&quot;&gt;&lt;a href=&quot;#指针和数组的对比&quot; class=&quot;headerlink&quot; title=&quot;指针和数组的对比&quot;&gt;&lt;/a&gt;指针和数组的对比&lt;/h3&gt;&lt;p&gt;指针和数组应该是c/c++程序员在编程过程中常打交道的类型了。而且二者在不少地方还可以相互替换着用，但是，请注意，二者有很大的区别。下面对c/c++指针和数组使用中注意项和易错项做下总结。(下述中p是指指针，a、b指数组)&lt;br&gt;(1) 数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（而不是指向）一块内存，其地址与容量在生命期内保持不变，只有数组的内容可以改变。指针可以随时指向任意类型的内存块，它的特征是“可变”，所以我们常用指针来操作动态内存。指针远比数组灵活，但也更危险。&lt;br&gt;(2) 若想把数组a的内容复制给数组b，不能用语句 b = a ，应该用标准库函数strcpy()进行复制。&lt;br&gt;(3) 比较数组b和a的内容是否相同，不能用if(b==a) 来判断，应该用标准库函数strcmp进行比较。&lt;br&gt;(4) 语句p = a 不是把a的内容复制指针p，而是把a的地址赋给了p。可以先用库函数malloc()为p申请一块容量为strlen(a)+1个字符的内存，再用strcpy()进行字符串复制。&lt;br&gt;(5) 语句if(p==a) 比较的不是内容而是地址，应该用库函数strcmp()来比较。&lt;br&gt;(6) 用运算符sizeof可以计算出数组的容量（字节数）（注意别忘了’\0’）。&lt;br&gt;(7) c/c++没有办法知道指针所指的内存容量，除非在申请内存时记住它。&lt;br&gt;(8) 当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。(即在函数内的用数组名的本质上是相应的指针)&lt;/p&gt;
&lt;h3 id=&quot;指针函数的传递&quot;&gt;&lt;a href=&quot;#指针函数的传递&quot; class=&quot;headerlink&quot; title=&quot;指针函数的传递&quot;&gt;&lt;/a&gt;指针函数的传递&lt;/h3&gt;&lt;p&gt;函数参数是指针时，在指针参数的传递时需要注意：&lt;br&gt;(1) 函数的参数是一个指针，不能用该指针去申请动态内存。&lt;br&gt;(2) 如果非得要使用指针参数去申请内存，那么应该改用”指向指针的指针”。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void GetMemory(char **p, int num)
{ 
    *p = (char *)malloc(sizeof(char) * num);
} 
void Test(void)
{ 
    char *str = NULL;
      GetMemory(&amp;amp;str, 100);   //参数是&amp;amp;str
    strcpy(str, &amp;quot;hello&amp;quot;);
       cout&amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;
       free(str);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(3) 由于“指向指针的指针”这个概念不容易理解，我们可以用函数返回值来传递动态内存。这种方法更加简单。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;char *GetMemory(int num)
{ 
    char *p = (char *)malloc(sizeof(char) * num); return p;    
} 
void Test(void)
{ 
    char *str = NULL;
     str = GetMemory3(100);
      strcpy(str, &amp;quot;hello&amp;quot;);
      cout&amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;
      free(str);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;待续&quot;&gt;&lt;a href=&quot;#待续&quot; class=&quot;headerlink&quot; title=&quot;待续&quot;&gt;&lt;/a&gt;待续&lt;/h3&gt;&lt;p&gt;内存管理是c/c++的最重要的问题之一，这里只是简单的对常见的内存分配与回收、内存错误及解决策略、指针和数组等问题进行了分析和总结。这部分理论较多，需很好的理解与掌握。 要是能自己再结合实际分析一下，就能更好地理解、掌握了。&lt;br&gt;以上，只是c/c++内存管理的一角，后面还将更深入探讨。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;可以说，内存管理是c/c++程序员面临的最重要的问题之一，同时很多时候也是最麻烦的事情。所以，这里对简单层次的内存管理做下总结和说明，同时，例举了一些常见的内存错误及解决策略。&lt;/p&gt;
&lt;h3 id=&quot;野指针&quot;&gt;&lt;a href=&quot;#野指针&quot; class=&quot;headerlink&quot; title=&quot;野指针&quot;&gt;&lt;/a&gt;野指针&lt;/h3&gt;&lt;p&gt;在c/c++内存问题中经常听到野指针这个词语，那么到底什么事野指针？野指针是怎样形成的？&lt;br&gt;首先，野指针不是NULL指针，而是指向”垃圾”内存的指针。NULL指针用if语句很容易判断，但是野指针很危险，if语句对其不起作用。&lt;br&gt;野指针的成因主要有下列几种：&lt;br&gt;(1) 指针变量没有初始化。 任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。&lt;br&gt;(2) 指针被free()或者delete之后，没有置为NULL，让人误以为其是个合法的指针。  这点是实际运用过程中极易犯错误的。&lt;br&gt;(3) 指针操作超越了变量的作用范围。&lt;br&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://blog.dujiong.net/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>动态规划之最长公共子序列，最长公共子串，最长递增子序列，最长子序列和等</title>
    <link href="http://blog.dujiong.net/2016/03/25/Seq&Substring/"/>
    <id>http://blog.dujiong.net/2016/03/25/Seq&Substring/</id>
    <published>2016-03-25T07:05:10.000Z</published>
    <updated>2016-06-28T11:03:42.060Z</updated>
    
    <content type="html">&lt;p&gt;近来，重新研究了动态规划的一些常见问题，特别是针对数组、子序列和串。学习过程又有了些新的看法与感悟，特记录如下。&lt;/p&gt;
&lt;p&gt;总结：动态规划是算法设计中非常重要的思想，值得我们多领悟、总结。&lt;br&gt;1.在研究动态规划过程中，一定要深刻理解递归解决公共子问题，并且要能将其和分治法区分开。&lt;br&gt;2.状态转移方程，就是反应解决动态规划的思路。当理解写出状态转移方程后，离成功就不远了。&lt;br&gt;3.针对很多关于串、子串的问题，注意边界问题的处理。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;最大子数组和&quot;&gt;&lt;a href=&quot;#最大子数组和&quot; class=&quot;headerlink&quot; title=&quot;最大子数组和&quot;&gt;&lt;/a&gt;最大子数组和&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-subarray/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;leetcode：maximum-subarray&lt;/a&gt;&lt;br&gt;说明：找出和最大的子数组。当然，子数组是连续的序列。&lt;br&gt;动态规划方案：使用两个变量，分别保存到目前为止的局部最优解和全局最优解。为什么要这样呢？因为，局部最优不一定是全局最优。  &lt;/p&gt;
&lt;p&gt;核心代码：   &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(int i=1; i&amp;lt;nums.size(); i++)
   {
   local = max(nums[i], nums[i]+local);
   global = max(global, local);
   }
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;最长递增子序列长度&quot;&gt;&lt;a href=&quot;#最长递增子序列长度&quot; class=&quot;headerlink&quot; title=&quot;最长递增子序列长度&quot;&gt;&lt;/a&gt;最长递增子序列长度&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-increasing-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;leetcode:longest increasing subsequence&lt;/a&gt;&lt;br&gt;说明：子序列，不要求连续。这里，只说明获取最长子序列的长度。&lt;br&gt;动态规划方案：使用dp[i]保存到目前为止的最长递增子序列长度，maxRet保存整个序列的最长递增子序列长度。把当前数据值与其前面所有的数据进行比较，从而更新子序列的长度。   &lt;/p&gt;
&lt;p&gt;核心代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; dp(n,0);
dp[0]=1; 
int maxRet=0;
for(int i=1; i&amp;lt;n; i++)
   {
   for(int j=0; j&amp;lt;i; j++)
   {
       if(nums[i]&amp;gt; nums[j])
           dp[i] = max(dp[i], dp[j]); 
       dp[i] += 1;    
       maxRet = max(maxRet, dp[i]); 
   }
   return maxRet;
   }
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;最长公共子串&quot;&gt;&lt;a href=&quot;#最长公共子串&quot; class=&quot;headerlink&quot; title=&quot;最长公共子串&quot;&gt;&lt;/a&gt;最长公共子串&lt;/h3&gt;&lt;p&gt;说明:找出两个字符串的最长公共字串。子串是连续的&lt;br&gt;动态规划方案：使用dp[i][j]表示以x[i]和y[j]结尾的最长公共子串的长度，因为子串是连续的，所以，对于x[i]与y[j]来讲，它们要么与之前的公共子串构成新的公共子串；要么不构成。故状态转移方程为：&lt;br&gt;（1） X[i]==Y[j], dp[i][j] = dp[i-1][j-1]+1;&lt;br&gt;（2） X[i]!=Y[j], dp[i][j] = 0&lt;br&gt;对于初始化，i==0或者j==0,如果x[i]=y[j],dp[i][j] = 1;否则dp[i][j]=0;     &lt;/p&gt;
&lt;p&gt;核心代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const string LCS(const string&amp;amp; str1,const string&amp;amp; str2)   //s1
{
    int xlen=str1.size();
    int ylen=str2.size();
    int maxlen=0;
    int maxindex=0;
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(xlen,vector&amp;lt;int&amp;gt;(ylen));
    for(int k=0;k&amp;lt;xlen;k++)
        for(int j=0;j&amp;lt;ylen;j++)
        {
            dp[k][j]=0;
        }
    int i=0;
    for(i=0;i&amp;lt;xlen;i++)
    {
        for(int j=0;j&amp;lt;ylen;j++)
        {
            if(str1[i]==str2[j])
            {
                if(i&amp;amp;&amp;amp;j)
                {
                     dp[i][j]=dp[i-1][j-1]+1;
                }
                if(i==0||j==0)
                {
                    dp[i][j]=1;
                }
                if(dp[i][j]&amp;gt;maxlen)
                {
                    maxlen = dp[i][j];
                    maxindex=i+1-maxlen;
                }
            }
        }
    }
    string res=str1.substr(maxindex,maxlen);
    return res;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;/p&gt;
&lt;h3 id=&quot;最长公共子序列&quot;&gt;&lt;a href=&quot;#最长公共子序列&quot; class=&quot;headerlink&quot; title=&quot;最长公共子序列&quot;&gt;&lt;/a&gt;最长公共子序列&lt;/h3&gt;&lt;p&gt;说明：相比于最长公共子串，差别在于公共子序列不要求数组中的元素连续。&lt;br&gt;和公共子串类似，不再啰嗦，直接上代码。     &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int LCSseq(const string&amp;amp; str1,const string&amp;amp; str2)
{
...
vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(xlen,vector&amp;lt;int&amp;gt;(ylen));
for(int i=0;i&amp;lt;xlen;i++)
    for(int j=0;j&amp;lt;len;j++)
    {
        if(str[i]==str2[j])
        {   
            if(i==0 || j==0)
                dp[i][j]=1; 
        }
        else
        {
            dp[i][j]=dp[i-1][j-1]+1;
        }
        else
        {
            if(i==0&amp;amp;&amp;amp;j==0)
                    continue;
            else if(i!=0&amp;amp;&amp;amp;j!=0)
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
            esle
                    dp[i][j]=1;
        }
    }    
    return dp[xlen-1][ylen-1];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;字符串编辑距离&quot;&gt;&lt;a href=&quot;#字符串编辑距离&quot; class=&quot;headerlink&quot; title=&quot;字符串编辑距离&quot;&gt;&lt;/a&gt;字符串编辑距离&lt;/h3&gt;&lt;p&gt;说明：给定一个源字符串和目标字符串，能够对源串进行如下操作：&lt;br&gt;(1)在给定位置上插入一个字符&lt;br&gt;(2)替换任意字符&lt;br&gt;(3)删除任意字符&lt;br&gt;所以，字符串编辑距离，是指两个字符串之间，由一个转换成另一个所需的最少操作次数。&lt;br&gt;动态规划方案：定义f[i,j]为子串str1[0…i]和str2[0…j]的最小编辑距离，则状态转移方程为：&lt;br&gt;f[i,j] = Min(f[i-1,j]+1,f[i,j-1]+1,f[i-1,j-1]+(str1[i]==str2[j]?0:1))  &lt;/p&gt;
&lt;p&gt;核心代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    int minDistance(string word1, string word2) 
    {
    int n1 = word1.size(), n2 = word2.size();
    int dp[n1 + 1][n2 + 1];
    for (int i = 0; i &amp;lt;= n1; ++i) dp[i][0] = i;
    for (int i = 0; i &amp;lt;= n2; ++i) dp[0][i] = i;
    for (int i = 1; i &amp;lt;= n1; ++i) 
    {
        for (int j = 1; j &amp;lt;= n2; ++j) 
        {
            if (word1[i - 1] == word2[j - 1]) 
            {
                dp[i][j] = dp[i - 1][j - 1];
            } 
            else 
            {
                dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;
            }
        }
    }
    return dp[n1][n2];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;待续&quot;&gt;&lt;a href=&quot;#待续&quot; class=&quot;headerlink&quot; title=&quot;待续&quot;&gt;&lt;/a&gt;待续&lt;/h3&gt;&lt;p&gt;这里通过几个典型实例简单说明了动态规划类问题的一些思路和方法。但是对于想很好的掌握动态规划，还是远远不够的。所以，还得多想，多领悟。 加油吧!&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;近来，重新研究了动态规划的一些常见问题，特别是针对数组、子序列和串。学习过程又有了些新的看法与感悟，特记录如下。&lt;/p&gt;
&lt;p&gt;总结：动态规划是算法设计中非常重要的思想，值得我们多领悟、总结。&lt;br&gt;1.在研究动态规划过程中，一定要深刻理解递归解决公共子问题，并且要能将其和分治法区分开。&lt;br&gt;2.状态转移方程，就是反应解决动态规划的思路。当理解写出状态转移方程后，离成功就不远了。&lt;br&gt;3.针对很多关于串、子串的问题，注意边界问题的处理。&lt;br&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="http://blog.dujiong.net/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>OpenWrt设置程序开机自启动</title>
    <link href="http://blog.dujiong.net/2016/03/18/startAP/"/>
    <id>http://blog.dujiong.net/2016/03/18/startAP/</id>
    <published>2016-03-18T09:05:23.000Z</published>
    <updated>2016-05-13T11:24:06.753Z</updated>
    
    <content type="html">&lt;h3 id=&quot;OpenWrt启动脚本&quot;&gt;&lt;a href=&quot;#OpenWrt启动脚本&quot; class=&quot;headerlink&quot; title=&quot;OpenWrt启动脚本&quot;&gt;&lt;/a&gt;OpenWrt启动脚本&lt;/h3&gt;&lt;p&gt;需要在OpenWrt中-将自己的程序设置为开机自启动。虽然OpenWrt是基于Linux的嵌入式发行版，但是和其设置方法还是略有差异，在此做一份记录。参考：&lt;a href=&quot;http://wiki.openwrt.org/doc/techref/initscripts&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://wiki.openwrt.org/doc/techref/initscripts&lt;/a&gt;&lt;br&gt;OpenWrt的启动脚本在/etc/init.d/目录下，而系统开机时自动运行/etc/rc.d/目录下的脚本，所以在rc.d目录下，有init.d脚本的连接文件。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;编写自己的启动脚本&quot;&gt;&lt;a href=&quot;#编写自己的启动脚本&quot; class=&quot;headerlink&quot; title=&quot;编写自己的启动脚本&quot;&gt;&lt;/a&gt;编写自己的启动脚本&lt;/h3&gt;&lt;p&gt;按照以下结构编写自己的shell脚本(这里以我的startAP为例说明)。特别注意一下，OpenWrt中的shell解析器与常用的Linux桌面、服务器（bash）不一样，记得当时写的时候就用的是#/bin/bash，后面找了好久才发现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/sh /etc/rc.common
#/init.d/startAP
START=50
start()
{
    ...
}
stop()
{
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在start()中写入需要开机运行的程序命令，在stop()中写入终止程序的命令。START=50是指优先级，数字越大，优先级越低。一般优先级高的脚本会先运行。&lt;br&gt;编写好自己的程序启动脚本后，熟悉Linux的都知道，要让程序执行，需要给脚本赋予可执行权限。所以，运行命令chmod+x xxx。&lt;/p&gt;
&lt;h3 id=&quot;为启动脚本做一个软链接&quot;&gt;&lt;a href=&quot;#为启动脚本做一个软链接&quot; class=&quot;headerlink&quot; title=&quot;为启动脚本做一个软链接&quot;&gt;&lt;/a&gt;为启动脚本做一个软链接&lt;/h3&gt;&lt;p&gt;如上所述，系统启动时会按顺序自动运行/etc/rc.d/目录下的脚本链接，对应执行/etc/init.d/目录下的启动脚本。所以，需要在/etc/rc.d/下为启动脚本创建一个链接。注意，链接文件要命名要规范，在脚本名前加S+启动顺序数字。顺便提一句，这里的启动顺序数字和前面所说到的优先级可是两码事。&lt;br&gt;所以，执行命令ln -s /etc/init.d/startAP /etc/rc.d/S95startAP创建链接。&lt;br&gt;最后，重启，就可以开机启动程序了。不妨使用ps查看一下吧。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;OpenWrt启动脚本&quot;&gt;&lt;a href=&quot;#OpenWrt启动脚本&quot; class=&quot;headerlink&quot; title=&quot;OpenWrt启动脚本&quot;&gt;&lt;/a&gt;OpenWrt启动脚本&lt;/h3&gt;&lt;p&gt;需要在OpenWrt中-将自己的程序设置为开机自启动。虽然OpenWrt是基于Linux的嵌入式发行版，但是和其设置方法还是略有差异，在此做一份记录。参考：&lt;a href=&quot;http://wiki.openwrt.org/doc/techref/initscripts&quot;&gt;http://wiki.openwrt.org/doc/techref/initscripts&lt;/a&gt;&lt;br&gt;OpenWrt的启动脚本在/etc/init.d/目录下，而系统开机时自动运行/etc/rc.d/目录下的脚本，所以在rc.d目录下，有init.d脚本的连接文件。&lt;br&gt;
    
    </summary>
    
    
      <category term="openwrt" scheme="http://blog.dujiong.net/tags/openwrt/"/>
    
  </entry>
  
  <entry>
    <title>配置OpenWrt路由器为Dumb AP</title>
    <link href="http://blog.dujiong.net/2016/03/15/dumbap/"/>
    <id>http://blog.dujiong.net/2016/03/15/dumbap/</id>
    <published>2016-03-15T13:21:29.466Z</published>
    <updated>2016-05-13T11:24:51.527Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Dumb-AP&quot;&gt;&lt;a href=&quot;#Dumb-AP&quot; class=&quot;headerlink&quot; title=&quot;Dumb AP&quot;&gt;&lt;/a&gt;Dumb AP&lt;/h2&gt;&lt;p&gt;Dumb AP，简单说，就是将路由器作为一个纯接入点，没有路由转发，没有DHCP。这时的路由器相当于一台二层交换机，没有三层功能。所以，实验环境中，将Dumb AP连接在上级路由器下，子网段为192.168.1.1/24。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置Dumb-AP&quot;&gt;&lt;a href=&quot;#配置Dumb-AP&quot; class=&quot;headerlink&quot; title=&quot;配置Dumb AP&quot;&gt;&lt;/a&gt;配置Dumb AP&lt;/h2&gt;&lt;h3 id=&quot;修改网络配置文件-etc-config-network&quot;&gt;&lt;a href=&quot;#修改网络配置文件-etc-config-network&quot; class=&quot;headerlink&quot; title=&quot;修改网络配置文件(/etc/config/network)&quot;&gt;&lt;/a&gt;修改网络配置文件(/etc/config/network)&lt;/h3&gt;&lt;p&gt;修改OpenWrt的网络配置文件，将wan口和lan口桥接起来:&lt;br&gt;&lt;code&gt;config interface lan&lt;/code&gt;&lt;br&gt;    &lt;code&gt;option type &amp;#39;bridge&amp;#39;&lt;/code&gt;&lt;br&gt;    &lt;code&gt;option ifname &amp;#39;eth0.1 eth0.2&amp;#39;&lt;/code&gt;  ##将二者桥接&lt;br&gt;    &lt;code&gt;option proto static&lt;/code&gt;&lt;br&gt;    &lt;code&gt;option ipaddr &amp;#39;192.168.1.196&amp;#39;&lt;/code&gt;  ##采用静态ip&lt;br&gt;    &lt;code&gt;option netmask 255.255.255.0&lt;/code&gt;&lt;br&gt;然后注释掉路由器关于wan口的设置，包括ipv4和ipv6。&lt;br&gt;需要说明的是，上述的配置文件中桥接的而是eth0.1和eth0.2，但事实上路由器的接口不尽相同，比如有的wan口事实上是eth1。所以，需要因地制宜。&lt;/p&gt;
&lt;h3 id=&quot;关掉DHCP&quot;&gt;&lt;a href=&quot;#关掉DHCP&quot; class=&quot;headerlink&quot; title=&quot;关掉DHCP&quot;&gt;&lt;/a&gt;关掉DHCP&lt;/h3&gt;&lt;p&gt;因为这里将路由器作为Dumb AP使用，作为一个纯无线接入点和交换机使用，不再需要其DHCP功能，所以关掉DHCP。&lt;br&gt;可以通过uci或者是修改配置文件(/etc/config/dhcp)设置DHCP。这里采用的是后者，即注释掉文件中lan口dhcp配置相关的设置。&lt;br&gt;&lt;code&gt;#config dhcp &amp;#39;lan&amp;#39;&lt;/code&gt;&lt;br&gt;    &lt;code&gt;#option interface &amp;#39;lan&amp;#39;&lt;/code&gt;&lt;br&gt;    &lt;code&gt;#option dhcpv6 &amp;#39;server&amp;#39;&lt;/code&gt;&lt;br&gt;    &lt;code&gt;#option ra &amp;#39;server&amp;#39;&lt;/code&gt;&lt;br&gt;    &lt;code&gt;#option ignore &amp;#39;1&amp;#39;&lt;/code&gt;&lt;br&gt;    &lt;code&gt;#option ra_management &amp;#39;1&amp;#39;&lt;/code&gt; &lt;/p&gt;
&lt;h3 id=&quot;关掉防火墙&quot;&gt;&lt;a href=&quot;#关掉防火墙&quot; class=&quot;headerlink&quot; title=&quot;关掉防火墙&quot;&gt;&lt;/a&gt;关掉防火墙&lt;/h3&gt;&lt;p&gt;某些情况下，需要关闭防火墙，同样的，修改配置文件/etc/config/firewall，将相应的REJECT改成ACCEPT即可，具体不再详述。&lt;br&gt;最后，载入新的配置即可。&lt;/p&gt;
&lt;h2 id=&quot;附：完整的-etc-config-network文件&quot;&gt;&lt;a href=&quot;#附：完整的-etc-config-network文件&quot; class=&quot;headerlink&quot; title=&quot;附：完整的/etc/config/network文件&quot;&gt;&lt;/a&gt;附：完整的/etc/config/network文件&lt;/h2&gt;&lt;p&gt;&lt;code&gt;config interface &amp;#39;loopback&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option ifname &amp;#39;lo&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option proto &amp;#39;static&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option ipaddr &amp;#39;127.0.0.1&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option netmask &amp;#39;255.0.0.0&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;config globals &amp;#39;globals&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option ula_prefix &amp;#39;fd9f:91f8:3d14::/48&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;config interface &amp;#39;lan&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option ifname &amp;#39;eth0.1 eth0.2&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option force_link &amp;#39;1&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option macaddr &amp;#39;b0:68:b6:ff:d6:b8&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option type &amp;#39;bridge&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option proto &amp;#39;static&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option ipaddr &amp;#39;192.168.1.196&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option netmask &amp;#39;255.255.255.0&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option ip6assign &amp;#39;60&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#config interface &amp;#39;wan&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;#option ifname &amp;#39;eth0.2&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;#option force_link &amp;#39;1&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;#option macaddr &amp;#39;b0:68:b6:ff:d6:b9&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;#option proto &amp;#39;dhcp&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#config interface &amp;#39;wan6&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;#option ifname &amp;#39;eth0.2&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;#option proto &amp;#39;dhcpv6&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;以下均保持原状&lt;/code&gt;&lt;br&gt;&lt;code&gt;config switch&lt;/code&gt;&lt;br&gt;&lt;code&gt;option name &amp;#39;switch0&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option reset &amp;#39;1&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option enable_vlan &amp;#39;1&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;config switch_vlan&lt;/code&gt;&lt;br&gt;&lt;code&gt;option device &amp;#39;switch0&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option vlan &amp;#39;1&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option ports &amp;#39;0 1 2 3 6t&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;config switch_vlan&lt;/code&gt;&lt;br&gt;&lt;code&gt;option device &amp;#39;switch0&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option vlan &amp;#39;2&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option ports &amp;#39;4 6t&lt;/code&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Dumb-AP&quot;&gt;&lt;a href=&quot;#Dumb-AP&quot; class=&quot;headerlink&quot; title=&quot;Dumb AP&quot;&gt;&lt;/a&gt;Dumb AP&lt;/h2&gt;&lt;p&gt;Dumb AP，简单说，就是将路由器作为一个纯接入点，没有路由转发，没有DHCP。这时的路由器相当于一台二层交换机，没有三层功能。所以，实验环境中，将Dumb AP连接在上级路由器下，子网段为192.168.1.1/24。&lt;br&gt;
    
    </summary>
    
    
      <category term="openwrt" scheme="http://blog.dujiong.net/tags/openwrt/"/>
    
  </entry>
  
  <entry>
    <title>Welcome to My Blog</title>
    <link href="http://blog.dujiong.net/2016/03/11/welcome/"/>
    <id>http://blog.dujiong.net/2016/03/11/welcome/</id>
    <published>2016-03-11T03:05:15.275Z</published>
    <updated>2016-03-18T08:24:03.699Z</updated>
    
    <content type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://blog.dujiong.net/&quot;&gt;My Blog&lt;/a&gt;! Happy Everyday！&lt;/p&gt;
&lt;p&gt;This is where i am writing and leaning. Let’s go!&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://blog.dujiong.net/&quot;&gt;My Blog&lt;/a&gt;! Happy Everyday！&lt;/p&gt;
&lt;p&gt;This is where i am writing and leaning. Let’s go!&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
</feed>
