<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一期一会</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.dujiong.net/"/>
  <updated>2016-05-13T11:13:37.606Z</updated>
  <id>http://blog.dujiong.net/</id>
  
  <author>
    <name>dujiong</name>
    <email>dujiong.uestc@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++内存管理--部分总结</title>
    <link href="http://blog.dujiong.net/2016/05/13/cplusplusMem/"/>
    <id>http://blog.dujiong.net/2016/05/13/cplusplusMem/</id>
    <published>2016-05-13T11:11:16.000Z</published>
    <updated>2016-05-13T11:13:37.606Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="C++" scheme="http://blog.dujiong.net/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>专题---动态规划之最长公共子序列，最长公共子串，最长递增子序列，最长子序列和等</title>
    <link href="http://blog.dujiong.net/2016/03/25/Seq&Substring/"/>
    <id>http://blog.dujiong.net/2016/03/25/Seq&Substring/</id>
    <published>2016-03-25T07:05:10.000Z</published>
    <updated>2016-05-13T11:34:32.165Z</updated>
    
    <content type="html">&lt;p&gt;近来，重新研究了动态规划的一些常见问题，特别是针对数组、子序列和串。学习过程又有了些新的看法与感悟，特记录如下。&lt;/p&gt;
&lt;p&gt;总结：动态规划是算法设计中非常重要的思想，值得我们多领悟、总结。  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在研究动态规划过程中，一定要深刻理解递归解决公共子问题，并且要能将其和分治法区分开。   &lt;/li&gt;
&lt;li&gt;状态转移方程，就是反应解决动态规划的思路。当理解写出状态转移方程后，离成功就不远了。   &lt;/li&gt;
&lt;li&gt;针对很多关于串、子串的问题，注意边界问题的处理。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;最大子数组和&quot;&gt;&lt;a href=&quot;#最大子数组和&quot; class=&quot;headerlink&quot; title=&quot;最大子数组和&quot;&gt;&lt;/a&gt;最大子数组和&lt;/h3&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-subarray/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;leetcode：maximum-subarray&lt;/a&gt;&lt;br&gt;说明：找出和最大的子数组。当然，子数组是连续的序列。&lt;br&gt;动态规划方案：使用两个变量，分别保存到目前为止的局部最优解和全局最优解。为什么要这样呢？因为，局部最优不一定是全局最优。  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;核心代码：   &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(int i=1; i&amp;lt;nums.size(); i++)
   {
   local = max(nums[i], nums[i]+local);
   global = max(global, local);
   }
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;最长递增子序列长度&quot;&gt;&lt;a href=&quot;#最长递增子序列长度&quot; class=&quot;headerlink&quot; title=&quot;最长递增子序列长度&quot;&gt;&lt;/a&gt;最长递增子序列长度&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-increasing-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;leetcode:longest increasing subsequence&lt;/a&gt;&lt;br&gt;说明：子序列，不要求连续。这里，只说明获取最长子序列的长度。&lt;br&gt;动态规划方案：使用dp[i]保存到目前为止的最长递增子序列长度，maxRet保存整个序列的最长递增子序列长度。把当前数据值与其前面所有的数据进行比较，从而更新子序列的长度。   &lt;/p&gt;
&lt;p&gt;核心代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; dp(n,0);
dp[0]=1; 
int maxRet=0;
for(int i=1; i&amp;lt;n; i++)
   {
   for(int j=0; j&amp;lt;i; j++)
   {
       if(nums[i]&amp;gt; nums[j])
           dp[i] = max(dp[i], dp[j]); 
       dp[i] += 1;    
       maxRet = max(maxRet, dp[i]); 
   }
   return maxRet;
   }
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;最长公共子串&quot;&gt;&lt;a href=&quot;#最长公共子串&quot; class=&quot;headerlink&quot; title=&quot;最长公共子串&quot;&gt;&lt;/a&gt;最长公共子串&lt;/h3&gt;&lt;p&gt;说明:找出两个字符串的最长公共字串。子串是连续的&lt;br&gt;动态规划方案：使用dp[i][j]表示以x[i]和y[j]结尾的最长公共子串的长度，因为子串是连续的，所以，对于x[i]与y[j]来讲，它们要么与之前的公共子串构成新的公共子串；要么不构成。故状态转移方程为：&lt;br&gt;（1） X[i]==Y[j], dp[i][j] = dp[i-1][j-1]+1;&lt;br&gt;（2） X[i]!=Y[j], dp[i][j] = 0&lt;br&gt;对于初始化，i==0或者j==0,如果x[i]=y[j],dp[i][j] = 1;否则dp[i][j]=0;     &lt;/p&gt;
&lt;p&gt;核心代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const string LCS(const string&amp;amp; str1,const string&amp;amp; str2)   //s1
{
    int xlen=str1.size();
    int ylen=str2.size();
    int maxlen=0;
    int maxindex=0;
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(xlen,vector&amp;lt;int&amp;gt;(ylen));
    for(int k=0;k&amp;lt;xlen;k++)
        for(int j=0;j&amp;lt;ylen;j++)
        {
            dp[k][j]=0;
        }
    int i=0;
    for(i=0;i&amp;lt;xlen;i++)
    {
        for(int j=0;j&amp;lt;ylen;j++)
        {
            if(str1[i]==str2[j])
            {
                if(i&amp;amp;&amp;amp;j)
                {
                     dp[i][j]=dp[i-1][j-1]+1;
                }
                if(i==0||j==0)
                {
                    dp[i][j]=1;
                }
                if(dp[i][j]&amp;gt;maxlen)
                {
                    maxlen = dp[i][j];
                    maxindex=i+1-maxlen;
                }
            }
        }
    }
    string res=str1.substr(maxindex,maxlen);
    return res;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;/p&gt;
&lt;h3 id=&quot;最长公共子序列&quot;&gt;&lt;a href=&quot;#最长公共子序列&quot; class=&quot;headerlink&quot; title=&quot;最长公共子序列&quot;&gt;&lt;/a&gt;最长公共子序列&lt;/h3&gt;&lt;p&gt;说明：相比于最长公共子串，差别在于公共子序列不要求数组中的元素连续。&lt;br&gt;和公共子串类似，不再啰嗦，直接上代码。     &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int LCSseq(const string&amp;amp; str1,const string&amp;amp; str2)
{
...
vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(xlen,vector&amp;lt;int&amp;gt;(ylen));
for(int i=0;i&amp;lt;xlen;i++)
    for(int j=0;j&amp;lt;len;j++)
    {
        if(str[i]==str2[j])
        {   
            if(i==0 || j==0)
                dp[i][j]=1; 
        }
        else
        {
            dp[i][j]=dp[i-1][j-1]+1;
        }
        else
        {
            if(i==0&amp;amp;&amp;amp;j==0)
                    continue;
            else if(i!=0&amp;amp;&amp;amp;j!=0)
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
            esle
                    dp[i][j]=1;
        }
    }    
    return dp[xlen-1][ylen-1];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;字符串编辑距离&quot;&gt;&lt;a href=&quot;#字符串编辑距离&quot; class=&quot;headerlink&quot; title=&quot;字符串编辑距离&quot;&gt;&lt;/a&gt;字符串编辑距离&lt;/h3&gt;&lt;p&gt;说明：给定一个源字符串和目标字符串，能够对源串进行如下操作：&lt;br&gt;(1)在给定位置上插入一个字符&lt;br&gt;(2)替换任意字符&lt;br&gt;(3)删除任意字符&lt;br&gt;所以，字符串编辑距离，是指两个字符串之间，由一个转换成另一个所需的最少操作次数。&lt;br&gt;动态规划方案：定义f[i,j]为子串str1[0…i]和str2[0…j]的最小编辑距离，则状态转移方程为：&lt;br&gt;f[i,j] = Min(f[i-1,j]+1,f[i,j-1]+1,f[i-1,j-1]+(str1[i]==str2[j]?0:1))  &lt;/p&gt;
&lt;p&gt;核心代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    int minDistance(string word1, string word2) 
    {
    int n1 = word1.size(), n2 = word2.size();
    int dp[n1 + 1][n2 + 1];
    for (int i = 0; i &amp;lt;= n1; ++i) dp[i][0] = i;
    for (int i = 0; i &amp;lt;= n2; ++i) dp[0][i] = i;
    for (int i = 1; i &amp;lt;= n1; ++i) 
    {
        for (int j = 1; j &amp;lt;= n2; ++j) 
        {
            if (word1[i - 1] == word2[j - 1]) 
            {
                dp[i][j] = dp[i - 1][j - 1];
            } 
            else 
            {
                dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;
            }
        }
    }
    return dp[n1][n2];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;待续&quot;&gt;&lt;a href=&quot;#待续&quot; class=&quot;headerlink&quot; title=&quot;待续&quot;&gt;&lt;/a&gt;待续&lt;/h3&gt;&lt;p&gt;这里通过几个典型实例简单说明了动态规划类问题的一些思路和方法。但是对于想很好的掌握动态规划，还是远远不够的。所以，还得多想，多领悟。 加油吧!&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;近来，重新研究了动态规划的一些常见问题，特别是针对数组、子序列和串。学习过程又有了些新的看法与感悟，特记录如下。&lt;/p&gt;
&lt;p&gt;总结：动态规划是算法设计中非常重要的思想，值得我们多领悟、总结。  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在研究动态规划过程中，一定要深刻理解递归解决公共子问题，并且要能将其和分治法区分开。   &lt;/li&gt;
&lt;li&gt;状态转移方程，就是反应解决动态规划的思路。当理解写出状态转移方程后，离成功就不远了。   &lt;/li&gt;
&lt;li&gt;针对很多关于串、子串的问题，注意边界问题的处理。
    
    </summary>
    
    
      <category term="algorithm" scheme="http://blog.dujiong.net/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>OpenWrt设置程序开机自启动</title>
    <link href="http://blog.dujiong.net/2016/03/18/startAP/"/>
    <id>http://blog.dujiong.net/2016/03/18/startAP/</id>
    <published>2016-03-18T09:05:23.000Z</published>
    <updated>2016-05-13T11:24:06.753Z</updated>
    
    <content type="html">&lt;h3 id=&quot;OpenWrt启动脚本&quot;&gt;&lt;a href=&quot;#OpenWrt启动脚本&quot; class=&quot;headerlink&quot; title=&quot;OpenWrt启动脚本&quot;&gt;&lt;/a&gt;OpenWrt启动脚本&lt;/h3&gt;&lt;p&gt;需要在OpenWrt中-将自己的程序设置为开机自启动。虽然OpenWrt是基于Linux的嵌入式发行版，但是和其设置方法还是略有差异，在此做一份记录。参考：&lt;a href=&quot;http://wiki.openwrt.org/doc/techref/initscripts&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://wiki.openwrt.org/doc/techref/initscripts&lt;/a&gt;&lt;br&gt;OpenWrt的启动脚本在/etc/init.d/目录下，而系统开机时自动运行/etc/rc.d/目录下的脚本，所以在rc.d目录下，有init.d脚本的连接文件。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;编写自己的启动脚本&quot;&gt;&lt;a href=&quot;#编写自己的启动脚本&quot; class=&quot;headerlink&quot; title=&quot;编写自己的启动脚本&quot;&gt;&lt;/a&gt;编写自己的启动脚本&lt;/h3&gt;&lt;p&gt;按照以下结构编写自己的shell脚本(这里以我的startAP为例说明)。特别注意一下，OpenWrt中的shell解析器与常用的Linux桌面、服务器（bash）不一样，记得当时写的时候就用的是#/bin/bash，后面找了好久才发现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/sh /etc/rc.common
#/init.d/startAP
START=50
start()
{
    ...
}
stop()
{
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在start()中写入需要开机运行的程序命令，在stop()中写入终止程序的命令。START=50是指优先级，数字越大，优先级越低。一般优先级高的脚本会先运行。&lt;br&gt;编写好自己的程序启动脚本后，熟悉Linux的都知道，要让程序执行，需要给脚本赋予可执行权限。所以，运行命令chmod+x xxx。&lt;/p&gt;
&lt;h3 id=&quot;为启动脚本做一个软链接&quot;&gt;&lt;a href=&quot;#为启动脚本做一个软链接&quot; class=&quot;headerlink&quot; title=&quot;为启动脚本做一个软链接&quot;&gt;&lt;/a&gt;为启动脚本做一个软链接&lt;/h3&gt;&lt;p&gt;如上所述，系统启动时会按顺序自动运行/etc/rc.d/目录下的脚本链接，对应执行/etc/init.d/目录下的启动脚本。所以，需要在/etc/rc.d/下为启动脚本创建一个链接。注意，链接文件要命名要规范，在脚本名前加S+启动顺序数字。顺便提一句，这里的启动顺序数字和前面所说到的优先级可是两码事。&lt;br&gt;所以，执行命令ln -s /etc/init.d/startAP /etc/rc.d/S95startAP创建链接。&lt;br&gt;最后，重启，就可以开机启动程序了。不妨使用ps查看一下吧。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;OpenWrt启动脚本&quot;&gt;&lt;a href=&quot;#OpenWrt启动脚本&quot; class=&quot;headerlink&quot; title=&quot;OpenWrt启动脚本&quot;&gt;&lt;/a&gt;OpenWrt启动脚本&lt;/h3&gt;&lt;p&gt;需要在OpenWrt中-将自己的程序设置为开机自启动。虽然OpenWrt是基于Linux的嵌入式发行版，但是和其设置方法还是略有差异，在此做一份记录。参考：&lt;a href=&quot;http://wiki.openwrt.org/doc/techref/initscripts&quot;&gt;http://wiki.openwrt.org/doc/techref/initscripts&lt;/a&gt;&lt;br&gt;OpenWrt的启动脚本在/etc/init.d/目录下，而系统开机时自动运行/etc/rc.d/目录下的脚本，所以在rc.d目录下，有init.d脚本的连接文件。&lt;br&gt;
    
    </summary>
    
    
      <category term="openwrt" scheme="http://blog.dujiong.net/tags/openwrt/"/>
    
  </entry>
  
  <entry>
    <title>配置OpenWrt路由器为Dumb AP</title>
    <link href="http://blog.dujiong.net/2016/03/15/dumbap/"/>
    <id>http://blog.dujiong.net/2016/03/15/dumbap/</id>
    <published>2016-03-15T13:21:29.466Z</published>
    <updated>2016-05-13T11:24:51.527Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Dumb-AP&quot;&gt;&lt;a href=&quot;#Dumb-AP&quot; class=&quot;headerlink&quot; title=&quot;Dumb AP&quot;&gt;&lt;/a&gt;Dumb AP&lt;/h2&gt;&lt;p&gt;Dumb AP，简单说，就是将路由器作为一个纯接入点，没有路由转发，没有DHCP。这时的路由器相当于一台二层交换机，没有三层功能。所以，实验环境中，将Dumb AP连接在上级路由器下，子网段为192.168.1.1/24。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置Dumb-AP&quot;&gt;&lt;a href=&quot;#配置Dumb-AP&quot; class=&quot;headerlink&quot; title=&quot;配置Dumb AP&quot;&gt;&lt;/a&gt;配置Dumb AP&lt;/h2&gt;&lt;h3 id=&quot;修改网络配置文件-etc-config-network&quot;&gt;&lt;a href=&quot;#修改网络配置文件-etc-config-network&quot; class=&quot;headerlink&quot; title=&quot;修改网络配置文件(/etc/config/network)&quot;&gt;&lt;/a&gt;修改网络配置文件(/etc/config/network)&lt;/h3&gt;&lt;p&gt;修改OpenWrt的网络配置文件，将wan口和lan口桥接起来:&lt;br&gt;&lt;code&gt;config interface lan&lt;/code&gt;&lt;br&gt;    &lt;code&gt;option type &amp;#39;bridge&amp;#39;&lt;/code&gt;&lt;br&gt;    &lt;code&gt;option ifname &amp;#39;eth0.1 eth0.2&amp;#39;&lt;/code&gt;  ##将二者桥接&lt;br&gt;    &lt;code&gt;option proto static&lt;/code&gt;&lt;br&gt;    &lt;code&gt;option ipaddr &amp;#39;192.168.1.196&amp;#39;&lt;/code&gt;  ##采用静态ip&lt;br&gt;    &lt;code&gt;option netmask 255.255.255.0&lt;/code&gt;&lt;br&gt;然后注释掉路由器关于wan口的设置，包括ipv4和ipv6。&lt;br&gt;需要说明的是，上述的配置文件中桥接的而是eth0.1和eth0.2，但事实上路由器的接口不尽相同，比如有的wan口事实上是eth1。所以，需要因地制宜。&lt;/p&gt;
&lt;h3 id=&quot;关掉DHCP&quot;&gt;&lt;a href=&quot;#关掉DHCP&quot; class=&quot;headerlink&quot; title=&quot;关掉DHCP&quot;&gt;&lt;/a&gt;关掉DHCP&lt;/h3&gt;&lt;p&gt;因为这里将路由器作为Dumb AP使用，作为一个纯无线接入点和交换机使用，不再需要其DHCP功能，所以关掉DHCP。&lt;br&gt;可以通过uci或者是修改配置文件(/etc/config/dhcp)设置DHCP。这里采用的是后者，即注释掉文件中lan口dhcp配置相关的设置。&lt;br&gt;&lt;code&gt;#config dhcp &amp;#39;lan&amp;#39;&lt;/code&gt;&lt;br&gt;    &lt;code&gt;#option interface &amp;#39;lan&amp;#39;&lt;/code&gt;&lt;br&gt;    &lt;code&gt;#option dhcpv6 &amp;#39;server&amp;#39;&lt;/code&gt;&lt;br&gt;    &lt;code&gt;#option ra &amp;#39;server&amp;#39;&lt;/code&gt;&lt;br&gt;    &lt;code&gt;#option ignore &amp;#39;1&amp;#39;&lt;/code&gt;&lt;br&gt;    &lt;code&gt;#option ra_management &amp;#39;1&amp;#39;&lt;/code&gt; &lt;/p&gt;
&lt;h3 id=&quot;关掉防火墙&quot;&gt;&lt;a href=&quot;#关掉防火墙&quot; class=&quot;headerlink&quot; title=&quot;关掉防火墙&quot;&gt;&lt;/a&gt;关掉防火墙&lt;/h3&gt;&lt;p&gt;某些情况下，需要关闭防火墙，同样的，修改配置文件/etc/config/firewall，将相应的REJECT改成ACCEPT即可，具体不再详述。&lt;br&gt;最后，载入新的配置即可。&lt;/p&gt;
&lt;h2 id=&quot;附：完整的-etc-config-network文件&quot;&gt;&lt;a href=&quot;#附：完整的-etc-config-network文件&quot; class=&quot;headerlink&quot; title=&quot;附：完整的/etc/config/network文件&quot;&gt;&lt;/a&gt;附：完整的/etc/config/network文件&lt;/h2&gt;&lt;p&gt;&lt;code&gt;config interface &amp;#39;loopback&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option ifname &amp;#39;lo&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option proto &amp;#39;static&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option ipaddr &amp;#39;127.0.0.1&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option netmask &amp;#39;255.0.0.0&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;config globals &amp;#39;globals&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option ula_prefix &amp;#39;fd9f:91f8:3d14::/48&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;config interface &amp;#39;lan&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option ifname &amp;#39;eth0.1 eth0.2&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option force_link &amp;#39;1&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option macaddr &amp;#39;b0:68:b6:ff:d6:b8&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option type &amp;#39;bridge&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option proto &amp;#39;static&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option ipaddr &amp;#39;192.168.1.196&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option netmask &amp;#39;255.255.255.0&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option ip6assign &amp;#39;60&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#config interface &amp;#39;wan&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;#option ifname &amp;#39;eth0.2&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;#option force_link &amp;#39;1&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;#option macaddr &amp;#39;b0:68:b6:ff:d6:b9&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;#option proto &amp;#39;dhcp&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#config interface &amp;#39;wan6&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;#option ifname &amp;#39;eth0.2&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;#option proto &amp;#39;dhcpv6&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;以下均保持原状&lt;/code&gt;&lt;br&gt;&lt;code&gt;config switch&lt;/code&gt;&lt;br&gt;&lt;code&gt;option name &amp;#39;switch0&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option reset &amp;#39;1&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option enable_vlan &amp;#39;1&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;config switch_vlan&lt;/code&gt;&lt;br&gt;&lt;code&gt;option device &amp;#39;switch0&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option vlan &amp;#39;1&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option ports &amp;#39;0 1 2 3 6t&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;config switch_vlan&lt;/code&gt;&lt;br&gt;&lt;code&gt;option device &amp;#39;switch0&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option vlan &amp;#39;2&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;option ports &amp;#39;4 6t&lt;/code&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Dumb-AP&quot;&gt;&lt;a href=&quot;#Dumb-AP&quot; class=&quot;headerlink&quot; title=&quot;Dumb AP&quot;&gt;&lt;/a&gt;Dumb AP&lt;/h2&gt;&lt;p&gt;Dumb AP，简单说，就是将路由器作为一个纯接入点，没有路由转发，没有DHCP。这时的路由器相当于一台二层交换机，没有三层功能。所以，实验环境中，将Dumb AP连接在上级路由器下，子网段为192.168.1.1/24。&lt;br&gt;
    
    </summary>
    
    
      <category term="openwrt" scheme="http://blog.dujiong.net/tags/openwrt/"/>
    
  </entry>
  
  <entry>
    <title>Welcome to My Blog</title>
    <link href="http://blog.dujiong.net/2016/03/11/welcome/"/>
    <id>http://blog.dujiong.net/2016/03/11/welcome/</id>
    <published>2016-03-11T03:05:15.275Z</published>
    <updated>2016-03-18T08:24:03.699Z</updated>
    
    <content type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://blog.dujiong.net/&quot;&gt;My Blog&lt;/a&gt;! Happy Everyday！&lt;/p&gt;
&lt;p&gt;This is where i am writing and leaning. Let’s go!&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://blog.dujiong.net/&quot;&gt;My Blog&lt;/a&gt;! Happy Everyday！&lt;/p&gt;
&lt;p&gt;This is where i am writing and leaning. Let’s go!&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
</feed>
